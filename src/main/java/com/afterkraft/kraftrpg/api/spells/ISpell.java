package com.afterkraft.kraftrpg.api.spells;

import org.bukkit.configuration.Configuration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.event.entity.EntityDamageEvent;

import com.afterkraft.kraftrpg.api.entity.Champion;

/**
 * @author gabizou
 */
public interface ISpell<T extends SpellArgument> {

    public String getPermissionNode();

    public String getName();

    public Configuration getDefaultConfig();

    public String getUsage();

    public void setUsage(String usage);

    public String getDescription();

    public void setDescription(String description);

    public void initialize();

    public void shutdown();

    /**
     * Request this spell to parse the given arguments executed by various
     * means. SpellArguments are state objects that RPGPlayers can cache for
     * binds and other possible uses.
     * 
     * @param champion
     *            - The Champion to be used, this is passed solely for the
     *            benefit of the SpellArgument creation
     * @param args
     *            - Raw string arguments that are passed from any source
     * @return a new SpellArgument object generated by this Spell for this
     *         Spell's use
     */
    public T parse(Champion champion, String[] args);

    /**
     * Cast this spell according to this spell's defined SpellArgument. This can
     * be used in instances like bound spells to Items and
     * 
     * @param champion
     *            - The Champion to cast this spell
     * @param argument
     *            - The SpellArgument to use this spell with
     * @return true if Spell usage was successfull
     */
    public boolean useSpell(Champion champion, T argument);

    public boolean addSpellTarget(Entity entity, Champion player);

    public boolean isType(SpellType type);

    public void knockback(LivingEntity target, LivingEntity attacker, double damage);

    public boolean damageEntity(LivingEntity target, LivingEntity attacker, double damage);

    public boolean damageEntity(LivingEntity target, LivingEntity attacker, double damage, EntityDamageEvent.DamageCause cause);

    public boolean damageEntity(LivingEntity target, LivingEntity attacker, double damage, EntityDamageEvent.DamageCause cause, boolean knockback);

}
